---
title: 'Witnessing the Jeep Grand Cherokee Hybrid Unveiling While on Acid at the Marcus Brothers Road Show in the Spring of 2008'
date: '08/27/2020'
---

Hey, let's build Tetris in React.

# Development Environment

For this project, I'm going to create a new react app...

and I'm going to use the TypeScript template.

We're not going to be relying too much on types, but they should help us stay focused.

I'll add a few more libraries, too.

For utilities, I'll add lodash-es.

I'll also add styled-components to help us with styling.

And, since we're using typescript, I'll also add the types for both libraries.

And finally, I'm going to be using my own library, State Designer, to manage our game's state and events. And that comes with its own types.

Now, if you're planning to build your own version of Tetris, you don't have to use this library — or any of these libraries, really — but they'll make it easier for us to define how the project should look—and, in the case of State Designer, how the project should _work_.

Ok, now I'll spin up the development server and we're ready to get building.

# Machine — what is Tetris?

Before we get into any presentation, let's set up our game's state.

I'll create a folder here in source named game.

And, inside of this folder, create a file named index.ts.

This file is going to hold all of our game's state — and we're going to use state designer to define that state, so let's import `createStateDesigner` from state designer.

I'll create an empty state called game...

And I'll make this the file's default export.

Before we get into defining our state, though, we should probably review Tetris itself.

What is Tetris, and how does it work?

# What is Tetris?

Tetris is a game where you fit together shapes in order to fill rows of a grid.

When you fill up a row, that row disappears and you score points.

The more rows you clear, the faster the game goes.

And, if you run out of space, then it's game over.

The game gets its name from the shapes, which are called tetrominos. A tetromino is a shape made up of four connected squares. There are seven types of tetrominos, named after their shapes — I, O, T, S and Z, and J and L.

Each of these shapes also has four rotations.

The game's grid is made up of cells — twenty rows of ten columns each — and each cell can either be empty or filled by one of the tetromino types.

The game starts with an empty grid and a current piece that the user can move left and right.

On an interval, this piece will move down one row.

If it can't move down — either because it's at the bottom of the screen, or because something is in the way — then the piece will lock into place.

When it does, if this means that the grid now has one or more full rows, then we'll remove these rows, move down the rows above it... then change the user's score, level, and so on.

Either way, the player will get a new piece to play.

This goes on until the player gives up or runs out of room and loses the game.

So alright, that's kind of a lot. But we can start breaking down the game into the data that matters.

# Types

I'm going to use TypeScript types to help us identify what all those parts of the game really are.

### Tetromino Types

Let's start with our Tetromino types. I'll enumerate all of the seven types.

```jsx
export enum TetrominoType {
  O = "O",
  I = "I",
  S = "S",
  Z = "Z",
  L = "L",
  J = "J",
  T = "T"
}
```

### Cell and Matric

The game's grid is going to be a 2D array — an array of rows, with each item in the array itself an array of columns. These columns, or **cells**, will either be empty — which we'll represent with the number zero, or full of one of our TetrominoType strings.

```jsx
export type Cell = 0 | TetrominoType
```

```jsx
export type Matrix = Cell[][]
```

### Tetromino

- Points represent positions, relative to an origin

```tsx
export type Point = { x: number; y: number }
```

- A tetromino is four points for each of the tetromino's four blocks

```jsx
export type Tetromino = [Point, Point, Point, Point]
```

### Tetrominos

We'll also need a collection of all of the different Tetrominos. This will be an object where all of the keys are TetrominoTypes and all of the values are Tetrominos.

But we're actually going to store an array of four Tetrominos for each type — one representing each rotation of the piece.

```jsx
export type Tetrominos = Record<TetrominoType, Tetromino[]>
```

### Tetrominos Static Object

Before we continue with our types, let's go make that object.

I'll create a new file named **static.ts**, that holds all the unchanging or "static" data that we'll rely on for our game.

For now, we'll just add our tetromino pieces.

We want to be sure to avoid collisions between the names of our types, and our other names, so let's bring in all of our exported types as Tetris.

```jsx
import * as Tetris from './types'
```

It'll need to have all of our seven types here, and for each type, I'll make an array, representing all four of the piece's rotations. And for each rotation, I'll make an array, representing all four of that rotation's rows... and for each row, I'll make an array represnting that row's cells. If that cell would be full, then I'll add a 1, otherwise a zero.

```jsx
export const tetrominos: Tetris.Tetrominos = {
  [Tetris.TetrominoType.O]: [
    [{ x: -1, y: 0 }, { x: 0, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }],
    [{ x: -1, y: 0 }, { x: 0, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }],
    [{ x: -1, y: 0 }, { x: 0, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }],
    [{ x: -1, y: 0 }, { x: 0, y: 0 }, { x: -1, y: 1 }, { x: 0, y: 1 }]
  ],
	...
}
```

I'll save you the trouble of watching me fill these out... but when I'm done, it will look like this.

### Colors

- types.ts

```jsx
export type Colors = Record<TetrominoType, string>
```

- static.ts

```jsx
export const colors: Tetris.Colors = {
  [Tetris.TetrominoType.O]: 'yellow',
  [Tetris.TetrominoType.I]: 'cyan',
  [Tetris.TetrominoType.S]: 'green',
  [Tetris.TetrominoType.Z]: 'red',
  [Tetris.TetrominoType.L]: 'orange',
  [Tetris.TetrominoType.J]: 'blue',
  [Tetris.TetrominoType.T]: 'purple',
}
```

### Piece

Finally, let's make a type for an actual piece in the game.

This will have a tetromino of a certain type...

and a rotation — a number between 0 and 3.

Finally, it will also have an origin — an object with an x and a y that we'll also type as a Point.

```jsx
export type Point = { x: number; y: number }

export type Piece = {
  type: TetrominoType
  orientation: number
  origin: Point
}
```

### Data

Okay, now that we have our data types defined, and we've even started on our static data, let's type all the data that our state will actually contain.

First, let's add that Grid that we defined above — the 2D array containing either zeros or TetrominoTypes from locked-in or falling pieces.

Next, we'll need a current piece, the falling piece that the user can control.

We'll need a next piece too.

And then we'll need a few numbers to keep track of the user's progress — their score, highscore, number of lines that they've cleared, and their current level.

```jsx
export type Data = {
  matrix: Matrix
  active: Piece
  next: TetrominoType[]
  score: number
  highscore: number
  lines: number
  level: number
}
```

And okay, that's all of our typing.

Even though we haven't created any actual data yet, writing types like this really helps me build out a mental model of how everything will fit together.

# State Data

So right, now that we have our types worked out, let's start actually defining our game's state.

## Initial Data

Let's start with the game's data object. We'll need to define this

- define above as initialData
- pass to machine

```jsx
const initialData: Tetris.Data = {
  matrix: range(20).map(() => range(10).map(() => 0)),
  active: {
    type: Tetris.TetrominoType.T,
    orientation: 0,
    origin: {
      x: 2,
      y: 1,
    },
  },
  next: [
    Tetris.TetrominoType.S,
    Tetris.TetrominoType.O,
    Tetris.TetrominoType.I,
    Tetris.TetrominoType.Z,
    Tetris.TetrominoType.T,
    Tetris.TetrominoType.J,
  ],
  score: 0,
  highscore: 0,
  lines: 0,
  level: 0,
}
```

# Components

### Grid

- exports a **Container**, **Cell**, and **Piece**
- used for Matrix — or Next cells
- next cells will need to be smaller

```tsx
import * as React from 'react'
import styled from 'styled-components'

import * as Tetris from '../game/types'
import * as Static from '../game/static'
```

### Container

```tsx
type ContainerProps = {
  rows: number
  columns: number
  size: number
}

export const Container = styled.div<ContainerProps>((props) => ({
  display: 'grid',
  gridTemplateColumns: `repeat(${props.columns}, ${props.size}px)`,
  gridTemplateRows: `repeat(${props.rows}, ${props.size}px)`,
  gridGap: 2,
}))
```

### Cell

```tsx
type CellProps = {
  x: number
  y: number
  cell: Tetris.Cell
}

export const Cell: React.FC<CellProps> = ({ x, y, cell }) => (
  <div
    style={{
      gridColumn: x + 1,
      gridRow: y + 1,
      backgroundColor: cell ? Static.colors[cell] : 'transparent',
      border: '1px solid #ccc',
    }}
  />
)
```

## Matrix

- Without active piece

```jsx
import * as React from 'react'
import { useStateDesigner } from 'state-designer'
import game from '../game'

import * as Grid from './Grid'

const Matrix: React.FC = () => {
  const { data } = useStateDesigner(game)
  const { matrix, active } = data

  return (
    <Grid.Container size={24} rows={20} columns={10}>
      {matrix.map((row, y) =>
        row.map((cell, x) => (
          <Grid.Cell key={y * 10 + x} x={x} y={y} cell={cell} />
        ))
      )}
    </Grid.Container>
  )
}

export default Matrix
```

- show in **App.tsx**

```jsx
import * as React from 'react'

import Matrix from './components/Matrix'

export default function App() {
  return (
    <div className="App">
      <Matrix />
    </div>
  )
}
```

## Piece

- add to grid

```tsx
// Grid.tsx
export const Piece: React.FC<Tetris.Piece> = ({
  type,
  orientation,
  origin,
}) => {
  const tetromino = Static.tetrominos[type][orientation]

  return (
    <>
      {tetromino.map((point, i) => (
        <Cell
          key={i}
          x={origin.x + point.x}
          y={origin.y + point.y}
          cell={type}
        />
      ))}
    </>
  )
}
```

- show in matrix

```jsx
// Matrix.tsx

const Matrix: React.FC = () => {
  const { data } = useStateDesigner(game)
  const { matrix, active } = data

  return (
    <Grid.Container size={24} rows={20} columns={10}>
      {matrix.map((row, y) =>
        row.map((cell, x) => (
          <Grid.Cell key={y * 10 + x} x={x} y={y} cell={cell} />
        ))
      )}
      <Grid.Piece {...active} />
    </Grid.Container>
  )
}
```

## Next

- Shows a list of next pieces
- Each piece has its own 4x4 grid
- origin will need to be offset

```tsx
import * as React from 'react'
import { useStateDesigner } from 'state-designer'
import game from '../game'

import * as Grid from './Grid'

const Next: React.FC = () => {
  const { data } = useStateDesigner(game)
  const { next } = data

  return (
    <div>
      {next.map((tetrominoType, i) => (
        <Grid.Container key={i} rows={4} columns={4} size={16}>
          <Grid.Piece
            type={tetrominoType}
            orientation={0}
            origin={{ x: 2, y: 1 }}
          />
        </Grid.Container>
      ))}
    </div>
  )
}

export default Next
```

- Show in App.tsx

```tsx
import * as React from 'react'

import Next from './components/Next'
import Matrix from './components/Matrix'

export default function App() {
  return (
    <div className="App" style={{ display: 'flex' }}>
      <Matrix />
      <Next />
    </div>
  )
}
```

# Gameplay

- add states
  - add repeat event to playing

### Falling piece

```jsx
repeat: {
  event: {
    do: "moveActivePieceDown",
  },
  delay: 1
},
```

## Only move if the next move fits

- result
  - use `cloneDeep` from lodash

```tsx
activePieceMovedDown(data) {
  const piece = cloneDeep(data.active)
  piece.origin.y += 1
  return piece
},
```

- condition

```jsx
pieceFitsInMatrix(data, _, piece: Tetris.Piece) {
  const { type, orientation, origin } = piece
  const tetromino = Static.tetrominos[type][orientation]

  return tetromino.every(point => {

    const matrixX = (origin.x + point.x)
    const matrixY = (origin.y + point.y)

    return data.matrix[matrixY]?.[matrixX] === 0
  })
},
```

- action

```tsx
moveActivePieceDown(data) {
  data.active.origin.y++
},
```

# Locking

## Can move down

```jsx
currentCanMoveDown(data) {
	const { type, orientation, origin } = data.active
  const tetromino = Static.tetrominos[type][orientation]

  return tetromino.every(point => {

    const matrixX = (origin.x + point.x)
    const matrixY = (origin.y + point.y) + 1

    return data.matrix[matrixY]?.[matrixX] === 0
  })
}
```

## Lock active into place

```tsx
const { type, orientation, origin } = data.active
const tetromino = Static.tetrominos[type][orientation]

tetromino.forEach((point) => {
  const matrixX = origin.x + point.x
  const matrixY = origin.y + point.y

  data.matrix[matrixY][matrixX] = type
})
```

## Get next active piece

```tsx
setActivePiece(data) {
  const type = data.next.shift() || Tetris.TetrominoType.S

  data.active = {
    type,
    origin: { x: 2, y: 1},
    orientation: 0
  }
},
```

## Add next piece

- uses sample from lodash

```tsx
import sample from 'lodash-es/sample'
```

```tsx
addNextPiece(data) {
	const randomType = sample(Tetris.TetrominoType) || Tetris.TetrominoType.S

  data.next.push(randomType)
}
```

### Final event:

```tsx
repeat: {
  event: [
    "moveActivePieceDown",
    {
    unless: "activePieceCanMoveDown",
    do: ["lockActivePieceIntoPlace", "setActivePiece", "addNextPiece"]
  }],
  delay: 1
}
```

# Inputs

- hook in app.tsx

```tsx
React.useEffect(() => {
  function handleKeydown(event: KeyboardEvent) {}

  document.body.addEventListener('keydown', handleKeydown)
  return () => {
    document.body.removeEventListener('keydown', handleKeydown)
  }
}, [])
```

- Switch key

```tsx
function handleKeydown(event: KeyboardEvent) {
  switch (event.key) {
    case 'ArrowLeft':
      break
    case 'ArrowRight':
      break
    case 'ArrowUp':
      break
    case 'ArrowDown':
      break
    default:
      break
  }
}
```

- Send events to game
- Start with left and right

```tsx
function handleKeydown(event: KeyboardEvent) {
  switch (event.key) {
    case "ArrowLeft":
      game.send("MOVED_LEFT")
      break
    case "ArrowRight":
      game.send("MOVED_RIGHT")
      break
		...
  }
}
```

- Add events to `playing` state

```tsx
on: {
  MOVED_LEFT: {},
  MOVED_RIGHT: {}
}
```

### Add results

- Return origin and orientation

```tsx
results: {
  activePieceMovedLeft(data) {
    const piece = cloneDeep(data.active)
    piece.origin.x -= 1
    return piece
  },
  activePieceMovedRight(data) {
    const piece = cloneDeep(data.active)
    piece.origin.x += 1
    return piece
  },
	...
},
```

### Actions

```tsx
moveActivePieceLeft(data) {
  data.active.origin.x--
},
moveActivePieceRight(data) {
  data.active.origin.x++
},
```

# Rotation

### Input

```tsx
case "ArrowUp":
  game.send("ROTATED_CLOCKWISE")
  break
```

### Event

```tsx
ROTATED_CLOCKWISE: {
  get: "activePieceRotatedClockwise",
  if: "pieceFitsInMatrix",
  do: "rotateActivePieceClockwise"
},
```

### Result

```tsx
activePieceRotatedClockwise(data) {
  const piece = cloneDeep(data.active)
  piece.orientation = (piece.orientation + 1) % 3
  return piece
},
```

### Action

```tsx
rotateActivePieceClockwise(data) {
  data.active.orientation = (data.active.orientation + 1) % 3
},
```

# Falling and Dropping

- Player can speed up drop while holding the down arrow
- Separate events for keydown and **keyup**
- Add event for arrowdown

```tsx
function handleKeydown(event: KeyboardEvent) {
  switch (event.key) {
		...
    case "ArrowDown":
      game.send("STARTED_DROP")
      break
  }
}
```

- Add keyup event listener / callback

```tsx
	...

	function handleKeyup(event: KeyboardEvent) { }

  document.body.addEventListener("keydown", handleKeydown)
  document.body.addEventListener("keyup", handleKeyup)
  return () => {
    document.body.removeEventListener("keydown", handleKeydown)
    document.body.removeEventListener("keyup", handleKeyup)
  }
```

- With send event

```tsx
function handleKeyup(event: KeyboardEvent) {
  switch (event.key) {
    case 'ArrowDown':
      game.send('STOPPED_DROP')
      break
    default:
      break
  }
}
```

- Add slow drop and fast drop states
- While the user holds down, enter "fast drop" state.

```tsx
playing: {
	on: { ... },
	initial: "falling",
	states: {
	  falling: {
	    repeat: {
	      event: [
	        {
	        get: "activePieceMovedDown",
	        if: "pieceFitsInMatrix",
	        do: "moveActivePieceDown",
	        elseDo: ["lockActivePieceIntoPlace", "setActivePiece", "addNextPiece"],
	      }],
	      delay: 1
	    },
	    on: {
	      STARTED_DROP: {
	        to: "dropping"
	      }
	    }
	  },
	  dropping: {
	    repeat: {
	      event: [
	        {
	        get: "activePieceMovedDown",
	        if: "pieceFitsInMatrix",
	        do: "moveActivePieceDown",
	        elseDo: ["lockActivePieceIntoPlace", "setActivePiece", "addNextPiece"],
	      }],
	      delay: .025
	    },
	    on: {
		    STOPPED_DROP: {
	        to: "falling"
	      }
	    }
	  },
	}
}
```

## Hard Drop

- Drops the piece all the way to the bottom and locks it
- keydown event
- add event to playing
- same as regular falling event, but will repeat until its conditions fail, and then lock into place.

```tsx
HARD_DROPPED: {
  get: "activePieceMovedDown",
  if: "pieceFitsInMatrix",
  do: "moveActivePieceDown",
  send: "HARD_DROPPED",
  elseDo: ["lockActivePieceIntoPlace", "setActivePiece", "addNextPiece"],
}
```

## Clearing Lines

- result

```tsx
fullLines(data) {
  let lines: number[] = []

  data.matrix.forEach((row, i) => {
    if (row.every(Boolean)) {
      lines.push(i)
    }
  })

  return lines
}
```

```tsx
containsFullLines(data) {
  return data.matrix.some(row => row.every(Boolean))
},
```

- condition

```tsx
hasLines(data, _, lines: number[]) {
  return lines.length > 0
},
```

- Remove full lines
- For each full line, move lines above it down,
- Then clear the top row

```tsx
clearLines(data, _, lines: number[]) {
  for (let i of lines) {
    for (let j = i; j > 0; j--) {
      data.matrix[j] = data.matrix[j - 1]
    }
  }

  data.matrix[0] = range(10).map(() => 0)
}
```

- Event

```tsx
event: [
    {
    get: "activePieceMovedDown",
    if: "pieceFitsInMatrix",
    do: "moveActivePieceDown",
    elseDo: ["lockActivePieceIntoPlace", "setActivePiece", "addNextPiece"],
  },{
    get: "fullLines",
    if: "hasLines",
    do: "clearLines"
  }],
  delay: .025
},
```

# Lines & Score

- Update lines, score when lines are cleared
- Add static scoes

```tsx
export const scores = [0, 40, 100, 300, 1200]
```

- Update player score

```tsx
updateScore(data, _, lines: number[]) {
  data.score += Static.scores[lines.length]
}
```

- Stats component

```tsx
import * as React from 'react'
import { useStateDesigner } from 'state-designer'
import game from '../game'

const Stats: React.FC = () => {
  const { data } = useStateDesigner(game)

  return (
    <div>
      <section>Score: {data.score}</section>
    </div>
  )
}

export default Stats
```

- Add to app.tsx

```tsx
<div className="App" style={{ display: 'flex' }}>
  <Matrix />
  <Next />
  <Stats />
</div>
```

# Gameover

Add `onEnter` to `playing`

```tsx
onEnter: [{
  do: ["setActivePiece", "addNextPiece"],
}, {
  unless: "pieceFitsInMatrix",
  to: "gameover"
}],
```

# Vanish Zone

- Add two extra "hidden" rows to matrix
- make cells array 22 long
- slice(-20) in matrix
- `const matrixY = origin.y + point.y + 2`

```tsx
const Matrix: React.FC = () => {
  const { data } = useStateDesigner(game)
  const { matrix, active } = data

  return (
    <Grid.Container size={24} rows={20} columns={10}>
      {matrix
        .slice(-20)
        .map((row, y) =>
          row.map((cell, x) => (
            <Grid.Cell key={y * 10 + x} x={x} y={y} cell={cell} />
          ))
        )}
      <Grid.Piece
        {...active}
        origin={{ ...active.origin, y: active.origin.y - 2 }}
      />
    </Grid.Container>
  )
}
```

## Ghost piece
